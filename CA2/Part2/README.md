# Techincal Report Of Class Assignment 2 Part 2

## General Introduction
The objective of Part 2 of the assignment is quite similar to the Part1, but all the work done was developed in a different branch. This technical report outlines the steps involved to finalize this Part 2.
Further details can be found at [https://github.com/AnaSofiaFigueiroaPinto/devops-23-24-JPE-PSM-1231822].

### To organize all the work properly, several issues were created in the GitHub repository
To do so, the following steps were taken:
1. In the main page of the repository, the "Issues" tab was clicked.
2. Then, the "New issue" button was clicked.
3. The title of the issue was added.
4. Then, the "Submit new issue" button was clicked.
5. The issue was created with a unique number, that should be used in the commit message that shows any editions related to the issue.

### The following steps were taken to complete the assignment:
1. Create a new branch in the repository, with the name "tut-basic-gradle":
```bash
   git branch tut-basic-gradle
   ```
2. Switch to the new branch:
```bash
   git checkout tut-basic-gradle
   ```
3. Then, go the following website: https://start.spring.io to generate a new spring boot project, with the required fields completed, taking into consideration the commands of the assignment's pdf. 

4. The project was downloaded and extracted into the CA2/Part2 folder:
```bash
   unzip react-and-spring-data-rest-basic.zip -d CA2/Part2
   ```
5. Then, inside the react-and-spring-data-rest-basic folder, the **src** folder was deleted:
```bash
    cd react-and-spring-data-rest-basic/
    rm -rf src
   ```
6. The **src** folder from Class Assignment 1 was copied into the folder:
```bash
   cp -r ~/Desktop/devops-23-24-JPE-PSM-1231822/CA1/tut-react-and-spring-data-rest/basic/src . 
   ```
7. Also, the files **webpack.config.js** and the **package.json** files from Class Assignment 1 were copied as well.
```bash
   cp ~/Desktop/devops-23-24-JPE-PSM-1231822/CA1/tut-react-and-spring-data-rest/basic/webpack.config.js .
   cp ~/Desktop/devops-23-24-JPE-PSM-1231822/CA1/tut-react-and-spring-data-rest/basic/package.json .
   ```
8. The folder **src/main/resources/static/built/** was also deleted:
```bash
   rm -rf src/main/resources/static/built/
   ```
8. To correctly use the ./gradlew bootRun, and to go further in this assignment, in the **Employee.java** file, the *javax.persistence* import was replaced by *jakarta.persistence*, since an error was detected if the first one was used.

9. Then, a gradle plugin was added to the project to allow the gradle to manage the frontend. To do so, the following line was added to the **build.gradle** file:
```gradle
   id "org.siouan.frontend-jdk17" version "8.0.0"
   ```
10. To correctly configure the previous plugin, the following code was also added to the **build.gradle** file:
```gradle
   frontend {
	nodeVersion = "16.20.2"
	assembleScript = "run build"
	cleanScript = "run clean"
	checkScript = "run check"
	}
   ```

11. In the package.json file, the following lines were added to the scripts section. To make the ./gradlew build successful, it was necessary to also add an extra line in the json file, as shown below:
```json
  "packageManager": "npm@9.6.7", (added line)
  "scripts": {
    "webpack": "webpack",
    "build": "npm run webpack",
    "check": "echo Checking frontend",
    "clean": "echo Cleaning frontend",
    "lint": "echo Linting frontend",
    "test": "echo Testing frontend"
},
   ```
12. The following command was used to build the project:
```bash
   ./gradlew build
   ```
13. After the build, the next command was used to run the project:
```bash
   ./gradlew bootRun
   ```
14. Afterwards, a task was added to the **build.gradle** file, to copy the generated jar to a folder named "dist", that is located at the project root folder level:
```gradle
   task copyJarToDist(type: Copy) {
	from 'build/libs/'
	into "${project.rootDir}/dist"
	include '*.jar'
}
   ```
15. Also, another task was added to the **build.gradle** file to delete all the files generated by webpack. This task was written taking into consideration the it should be executed by gradle before the task *clean*:
```gradle
   task cleanWebpack(type: Delete) {
	delete fileTree(dir: "${project.projectDir}/src/main/resources/static/built")
}

clean.dependsOn cleanWebpack
   ```
16. Lastly, the branch tut-basic-gradle was merged into the main branch, and the project was pushed to the GitHub repository.
```bash
   git checkout main
   git merge --no-ff tut-basic-gradle
   git push origin main
   ```

### Alternative version - using Apache Ant:
To build the project using Apache Ant, the following steps should be taken to successfully accomplish the CA2 Part 2 assignment:

Create a new branch:
```xml
<exec executable="git" failonerror="true">
<arg line="checkout -b tut-basic-gradle"/>
</exec>
````
Extract the generated zip file:
```xml
<unzip src="~/to/generated/zip/file.zip" dest="CA2/Part2"/>
```
Delete the src folder:
```xml
<delete dir="CA2/Part2/src"/>
```

Copy the src folder, webpack.config.js, and package.json:

```xml
<copy todir="CA2/Part2">
<fileset dir="~/Desktop/devops-23-24-JPE-PSM-1231822/CA1/tut-react-and-spring-data-rest/basic/">
<include name="src/**"/>
<include name="webpack.config.js"/>
<include name="package.json"/>
</fileset>
</copy>
```
Delete the src/main/resources/static/built/ folder:
```xml
<delete dir="CA2/Part2/src/main/resources/static/built"/>
```

Since Ant does not support plugins like Gradle does, it is needed to manually handle frontend build tasks.

Meaning, it is necessary to define custom Ant tasks or scripts to mimic the functionality provided by the plugin.

Update scripts section in package.json:

```xml
<replace file="CA2/Part2/package.json" token="scripts" value='"scripts": {
"webpack": "webpack",
"build": "npm run webpack",
"check": "echo Checking frontend",
"clean": "echo Cleaning frontend",
"lint": "echo Linting frontend",
"test": "echo Testing frontend"
}'/>
```
Since it is not possible to integrate Ant with the frontend as tightly as Maven or Gradle can, to achieve something similar in Ant, it is needed to custom Ant tasks through the '< exec >' task to run the frontend build commands.

Execute the application:
```xml
<exec executable="gradlew" dir="CA2/Part2" failonerror="true">
<arg value="bootRun"/>
</exec>
```


Add a task to copy the generated jar:

```xml
<target name="copyJarToDist">
    <echo message="Copying JAR files to distribution directory..."/>
    <copy todir="${basedir}/dist">
        <fileset dir="${basedir}/build/libs" includes="*.jar"/>
    </copy>
</target>
```

Add a task to delete files generated by webpack:

```xml
<target name="cleanWebpack">
    <echo message="Cleaning webpack-generated files..."/>
    <delete dir="${basedir}/src/main/resources/static/built"/>
</target>
```
```xml
<target name="clean" depends="cleanWebpack">
    <echo message="Cleaning project..."/>

</target>
```

## Main difference between the Apache Ant and Gradle: 
Comparing the build file syntax for both build tools, Ant typically uses XML for defining build scripts. Each task is represented by an XML element with attributes and nested elements.
On the other hand, Gradle uses Groovy or Kotlin for build scripts (in this project, it uses Groovy). The syntax is more concise and expressive compared to XML, allowing for more flexibility and readability.

Regarding the dependencies management, Ant does not have built-in dependency management. Usually, it is possible to manage dependencies manually by including JAR files in the project's classpath or referencing them directly in the build script.
Gradle has a powerful built-in dependency management system that automatically resolves and downloads dependencies from repositories like Maven Central. The dependencies in the build script are specified and then Gradle handles the rest.

In the matter of tasks configuration Ant requires explicit configuration for each task. It is needed to specify every detail in the build script.
Differently, Gradle follows the convention over configuration principle, providing sensible defaults and reducing the need for explicit configuration. This makes build scripts shorter and more maintainable.


For extensibility and usage of plugins, Ant provides a core set of tasks for common build operations. Additional functionality is often added through third-party libraries or custom tasks.
Quite the opposite, Gradle offers a rich ecosystem of plugins for various tasks like testing, code quality checks, deployment, etc. It is also possible to write custom plugins to extend Gradle's functionality as needed.

Necessary builds are handled quite differently on both of the build tools. Ant typically executes tasks sequentially, rebuilding everything from scratch each time.
Gradle supports incremental builds, where it only rebuilds what's necessary based on changes since the last build. This can significantly improve build times for large projects.

For IDE integration, Ant build scripts can be integrated into IDEs, but they often require additional setup and configuration, making it a bit more troublesome to use.
Gradle has better integration with IDEs like IntelliJ IDEA and Android Studio, providing features like auto-import of dependencies and build script navigation.

In summary, while both Ant and Gradle are used for similar purposes, Gradle offers more advanced features, better dependency management, and a more modern and flexible approach to build automation.




